---
title: "Lab Lecture 9"
author: "Kenji Tomari"
output: 
  html_document:
    theme: readable
    toc: true
    toc_depth: 3
    toc_float: true
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Raster

## Readings

These are for reference, and not required. However, if you find yourself thinking you'll work with such things as orthophotos (i.e. satellite photos) or some other field data, I would recommend reading through the sections on {raster} in greater detail.

* [Summary](https://rspatial.org/raster/spatial/2-spatialdata.html#raster-data)
* [Data Format](https://rspatial.org/raster/spatial/4-rasterdata.html)
* [Reading & Writing](https://rspatial.org/raster/spatial/5-files.html#raster-files)
* [Projection & Transformation](https://rspatial.org/raster/spatial/6-crs.html#transforming-raster-data)
* [Data Manipulation](https://rspatial.org/raster/spatial/8-rastermanip.html)
* [Maps](https://rspatial.org/raster/spatial/9-maps.html#raster)

# Interpolation Lab

## Question 1

You should be able to comment most of this code chunk fairly simply by comparing it to last week's lab. However, I think the last line of code is perhaps more difficult to directly interpret: essentially, we're making a comparison between our proximity polygons model and mean model. Strictly speaking, it is a fraction by which our proximity polygon model performs better than the mean (null) model. This [answer](https://stats.stackexchange.com/questions/218418/comparing-rmse-to-model#answer-218493) on stackexchange seems to discuss this measure of comparison between a test model and a null model. It suggests that it's similar to R^2 (but that it isn't R^2 strictly speaking).

## Question 2

Compare the RMSE values.

Sidebar: Did you know Proximity Polygons are also known by the name **Nearest Neighbor Interpolation**?

## Question 3

> See OSU p. 254.

## Question 4

In answering this question you might pay attention to the very first map we made with `spplot(dsp, 'prec', cuts=cuts, col.regions=blues(5), sp.layout=pols, pch=20, cex=2)`. Notice where the control points are, and where they are not located. Here's also some code as a hint (run it!): `mean(dta@data$prec)`.

> "It is important to notice that the IDW interpolation method also has some disadvantages: the quality of the interpolation result can decrease, if the distribution of sample data points is uneven." ([QGIS](https://docs.qgis.org/2.8/en/docs/gentle_gis_introduction/spatial_analysis_interpolation.html#inverse-distance-weighted-idw))

## Question 5

Hint: Look in the documentation on {gstat} to understand the arguments we haven't come across yet, like `nmax`. You can use this code to read the documentation: `?gstat::gstat`. Understanding `set` is a bit more complicated from the documentation, and its less relevant for answering this question[^1]. So, if `nmax = 1`, how many control points are each predicted point relying upon? You should compare the map produced here with the previous maps we've produced to ascertain the proper name of this model.

[^1]: Here, you have to read the [gstat standalone guide](http://www.gstat.org/gstat.pdf). On p. 40 it begins to describe what the `set` argument takes in as its' values. In short, `idp` is the power function *k* of equation 9.9 in OSU p. 260. (FYI, The funky symbol in 9.9 that looks like an truncated infinity symbol is read as "proportional to".) By default, the idp is set to 2 (as indicated with most computer programs in OSU p260). Again, however, `set` in this question is less important than `nmax`.