<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Point Pattern Analysis</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="styles.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">GEO 200CN: Winter 2020</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="syllabus.html">Syllabus</a>
</li>
<li>
  <a href="hw_guidelines.html">Assignment Guidelines</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Labs
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="tidyr.html">Tidy R</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Other
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a></a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">

<div class="btn-group pull-right">
<button type="button" class="btn btn-default btn-xs dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Point Pattern Analysis</h1>
<h3 class="subtitle"><h4 style="font-style:normal">
GEO 200CN - Quantitative Geography
</h4></h3>
<h4 class="author"><h4 style="font-style:normal">
Professor Noli Brazil
</h4></h4>
<h4 class="date"><h4 style="font-style:normal">
April 21, 2020
</h4></h4>

</div>


<style>
p.comment {
background-color: #DBDBDB;
padding: 10px;
border: 1px solid black;
margin-left: 25px;
border-radius: 5px;
font-style: italic;
}

.figure {
   margin-top: 20px;
   margin-bottom: 20px;
}

h1.title {
  font-weight: bold;
  font-family: Arial;  
}

h2.title {
  font-family: Arial;  
}

</style>
<style type="text/css">
#TOC {
  font-size: 13px;
  font-family: Arial;
}
</style>
<p><br />
</p>
<p>The fundamental building blocks of vector or object data are points. As such, we start out journey into spatial data analysis by going through the basic methods for examining point patterns. This guide follows closely OSU Chapter 4.</p>
<div style="margin-bottom:25px;">

</div>
<div id="installing-and-loading-packages" class="section level2">
<h2><strong>Installing and loading packages</strong></h2>
<p><br />
We’ll be using a couple of new packages in this lab. First, you’ll need to install them. The code checks if you’ve already installed these packages before. If you haven’t, it will install them.</p>
<pre class="r"><code>if (!require(&quot;rspatial&quot;)) devtools::install_github(&#39;rspatial/rspatial&#39;)
if (!require(&quot;spatstat&quot;)) install.packages(&quot;spatstat&quot;)
if (!require(&quot;maptools&quot;)) install.packages(&quot;maptools&quot;)</code></pre>
<p>Next, load these and the <strong>sf</strong> package for this lab using the function <code>library()</code></p>
<pre class="r"><code>library(sf)
library(maptools)
library(spatstat)
library(rspatial)</code></pre>
<div style="margin-bottom:25px;">

</div>
</div>
<div id="setting-up-the-data" class="section level2">
<h2><strong>Setting up the data</strong></h2>
<p><br />
We are using a dataset of crimes in a city. You can get these data from the <strong>rspatial</strong> package that you can install from GitHub using the <strong>devtools</strong> package. Bring in the data using the following code</p>
<pre class="r"><code>city &lt;- sp_data(&quot;city&quot;)
crime &lt;- sp_data(&quot;crime.rds&quot;)</code></pre>
<p><em>city</em> is an <strong>sp</strong> spatial polygon object containing the boundaries of a city. <em>crime</em> is an <strong>sp</strong> spatial points object containing crimes in the city. To see what we got, plot it</p>
<pre class="r"><code>par(mai=c(0,0,0,0))
plot(city, col=&#39;light blue&#39;)
points(crime, col=&#39;red&#39;, cex=.5, pch=&#39;+&#39;)</code></pre>
<p><img src="pointpatterns_files/figure-html/unnamed-chunk-4-1.png" /><!-- --></p>
<p>All point pattern analysis tools used in this tutorial are available in the <strong>spatstat</strong> package. These tools are designed to work with points stored as <em>ppp</em> objects and not <em>SpatialPointsDataFrame</em> or <em>sf</em> objects. So, yes, another spatial object to learn about.</p>
<p>To convert our <strong>sp</strong> <em>crime</em> points object into a <em>ppp</em>, use the <code>as()</code> function</p>
<pre class="r"><code>crime.ppp &lt;- as(crime, &quot;ppp&quot;)</code></pre>
<p>Note that a <em>ppp</em> object may or may not have attribute information (also referred to as <em>marks</em> or <em>Mark variables</em> in the <strong>spatstat</strong> world).</p>
<pre class="r"><code>crime.ppp</code></pre>
<pre><code>## Marked planar point pattern: 2661 points
## Mark variables: 
##    CATEGORY CASEN ODT1 OFFDESC1 OFFDESC2 OFFDESC3 OFFDESC4 OFFDESC5 OFFDESC6
## window: rectangle = [6620751, 6653993] x [1957331.9, 1971237.4] units</code></pre>
<p>Knowing whether or not a function requires that an attribute table be present in the <em>ppp</em> object matters if the operation is to complete successfully. In this lab we will only concern ourselves with the pattern generated by the points and not their attributes. We’ll therefore remove all marks from the point object.</p>
<pre class="r"><code>marks(crime.ppp)  &lt;- NULL</code></pre>
<p>Many point pattern analyses should have their study boundaries explicitly defined. This is the window through which we are observing the points. <strong>spatstat</strong> uses a special boundary object - an <em>owin</em>, which stands for observation window. We will need to coerce <em>city</em> to an object of class <em>owin</em> using the function <code>as.owin()</code></p>
<pre class="r"><code>cityOwin &lt;- as.owin(city)
class(cityOwin)</code></pre>
<pre><code>## [1] &quot;owin&quot;</code></pre>
<p>To set or “bind” the city boundary <em>owin</em> to the <em>crime</em> point feature object, use the <code>Window()</code> function, which is a <strong>spatstat</strong> function.</p>
<pre class="r"><code>Window(crime.ppp) &lt;- cityOwin</code></pre>
<p>We can now plot the data to see what we have</p>
<pre class="r"><code>par(mai=c(0,0,0,0))
plot(city, col=&#39;light blue&#39;)
points(crime.ppp, col=&#39;red&#39;, cex=.5, pch=&#39;+&#39;)</code></pre>
<p><img src="pointpatterns_files/figure-html/unnamed-chunk-10-1.png" /><!-- --></p>
<div style="margin-bottom:25px;">

</div>
</div>
<div id="centrography" class="section level2">
<h2><strong>Centrography</strong></h2>
<p><br />
Before considering more complex approaches, let’s compute the mean center and standard distance for the crime data as described on page 125 of OSU. To calculate these values, you’ll need to extract the x and y coordinates from the <em>crime.ppp</em> object using the function <code>coords()</code></p>
<pre class="r"><code>xy &lt;- coords(crime.ppp)</code></pre>
<p>And then compute the values following equations on page 125</p>
<pre class="r"><code># mean center
mc &lt;- apply(xy, 2, mean)
# standard distance
sd &lt;- sqrt(sum((xy[,1] - mc[1])^2 + (xy[,2] - mc[2])^2) / nrow(xy))</code></pre>
<div style="margin-bottom:25px;">

</div>
</div>
<div id="density-based-measures" class="section level2">
<h2><strong>Density based measures</strong></h2>
<p><br />
A point pattern can be thought of as a “realization” of an underlying process whose intensity λ is estimated from the observed point pattern’s density. The overall density given in the formula 5.3 in OSU can be calculated as</p>
<pre class="r"><code>CityArea &lt;- area(city)
dens &lt;- nrow(xy) / CityArea</code></pre>
<p>As OSU states, we lose a lot of information when we calculate a single summary statistic like overall density. We go through the two “local” density approaches covered in OSU: Kernel and Quadrat density.</p>
<div style="margin-bottom:25px;">

</div>
<div id="kernel-density" class="section level3">
<h3><strong>Kernel density</strong></h3>
<p><br />
The <strong>spatstat</strong> package has a function called <code>density()</code> which computes an isotropic kernel intensity estimate of the point pattern. Its bandwidth defines the kernel’s window extent.</p>
<pre class="r"><code>ds &lt;- density(crime.ppp, bandwidth = 0.5)
par(mai=c(0,0,0.5,0.5))
plot(ds, main=&#39;crime density&#39;)</code></pre>
<p><img src="pointpatterns_files/figure-html/unnamed-chunk-14-1.png" /><!-- --></p>
<p>A discussion of kernel density maps is located in page 68-71 in OSU. Many of the parameters discussed, such as the bandwidth and the type of smoothing function, can be changed in <code>density()</code>.</p>
<div style="margin-bottom:25px;">

</div>
</div>
<div id="quadrat-counts" class="section level3">
<h3><strong>Quadrat counts</strong></h3>
<p><br />
To compute quadrat counts (as on p.127-130), use <strong>spatstat</strong>’s <code>quadratcount()</code> function. The following code chunk divides the city boundary into a grid of 3 rows and 6 columns then tallies the number of points falling in each quadrat.</p>
<pre class="r"><code>qcounts1 &lt;- quadratcount(crime.ppp, nx= 6, ny=3)</code></pre>
<p>The object Q stores the number of points inside each quadrat. You can plot the quadrats along with the counts as follows:</p>
<pre class="r"><code>plot(crime.ppp, pch=20, cols=&quot;grey70&quot;, main=NULL)  # Plot points
plot(qcounts1, add=TRUE)  # Add quadrat grid</code></pre>
<p><img src="pointpatterns_files/figure-html/unnamed-chunk-16-1.png" /><!-- --></p>
<p>Three-by-six might be too small. Let’s instead make a 15 by 30 grid.</p>
<pre class="r"><code>qcounts2 &lt;- quadratcount(crime.ppp, nx= 30, ny=15)
plot(crime.ppp, pch=20, cols=&quot;grey70&quot;, main=NULL)  # Plot points</code></pre>
<p><img src="pointpatterns_files/figure-html/unnamed-chunk-17-1.png" /><!-- --></p>
<pre class="r"><code>plot(qcounts2)  # Add quadrat grid. </code></pre>
<p><img src="pointpatterns_files/figure-html/unnamed-chunk-17-2.png" /><!-- --></p>
<p>We’ll need to convert the resulting <em>qcounts2</em> object into a data frame to calculate the variance-mean ratio (VMR).</p>
<pre class="r"><code>Qcount&lt;-data.frame(qcounts2)</code></pre>
<p>And the VMR is</p>
<pre class="r"><code>var(Qcount$Freq)/mean(Qcount$Freq)</code></pre>
<pre><code>## [1] 32.25635</code></pre>
<p>In real life one should always try a range of row and column sizes to get a sense of how sensitive your results are.</p>
<p><br></p>
<p class="comment" , style="font-style:normal">
<strong>Question 1</strong>: What does this VMR score tell us about the point pattern?
</p>
<p><br></p>
<div style="margin-bottom:25px;">

</div>
</div>
</div>
<div id="distance-based-measures" class="section level2">
<h2><strong>Distance based measures </strong></h2>
<p><br />
An alternative to density based methods are distance based methods whereby the interest lies in how the points are distributed relative to one another (a second-order property of the point pattern) as opposed to how the points are distributed relative to the study extent.</p>
<div style="margin-bottom:25px;">

</div>
<div id="nearest-neighbor-distances" class="section level3">
<h3><strong>Nearest-Neighbor Distances</strong></h3>
<p><br />
The first distance-based method that OSU goes through is calculating the mean nearest neighbor (MNN) distance. Here, you calculate for each point the distance to its nearest neighbor. You do this using the function <code>nndist()</code>, which is a part of the <strong>spatstat</strong> package.</p>
<pre class="r"><code>mnn.p &lt;- mean(nndist(crime.ppp, k=1))
mnn.p</code></pre>
<pre><code>## [1] 53.7598</code></pre>
<p>We plug <em>crime.ppp</em> into <code>nndist()</code>, resulting in a numeric vector containing nearest distance for each point, and take the mean. The argument <code>k=1</code>, which is the default, calculates the distance to the first nearest neighbor. This gives us a mean nearest neighbor distance of 53.7598 feet (check <code>crs(crime)</code> to find how we got feet as the units of distance).</p>
<div style="margin-bottom:25px;">

</div>
<div id="hypothesis-testing" class="section level4">
<h4><strong>Hypothesis testing</strong></h4>
<p><br />
The value 53.7598 seems small, indicating that crime clusters. But, we can formally test this using the Clark and Evan’s R statistic described on OSU page 143. The <strong>spatstat</strong> package has the function <code>clarkevans.test()</code> for calculating this statistic.</p>
<pre class="r"><code>clarkevans.test(crime.ppp)</code></pre>
<pre><code>## 
##  Clark-Evans test
##  No edge correction
##  Z-test
## 
## data:  crime.ppp
## R = 0.33215, p-value &lt; 2.2e-16
## alternative hypothesis: two-sided</code></pre>
<p><br></p>
<p class="comment" , style="font-style:normal">
<strong>Question 2</strong>: What does this results of the Clark Evans test tell us about the point pattern?
</p>
<p><br></p>
<p>OSU Ch. 5.4 discusses using Monte Carlo testing to statistically test for point clustering. Rather than assume a distribution, as the Clark Evans test does, we create a random distribution non parametrically.</p>
<p>First, generate the distribution of expected MNN values given a homogeneous (CSR/IRP) point process using Monte Carlo methods. This is our null model.</p>
<pre class="r"><code># Number of simulations
n &lt;- 599               
# Create an empty object to be used to store simulated MNN values
mnn.r &lt;- vector(length = n) 
for (i in 1:n){
  # Generate random point locations
  rand.p   &lt;- rpoint(n=crime.ppp$n, win = cityOwin)  
  # Tally the MNN values
  mnn.r[i] &lt;- mean(nndist(rand.p, k=1))  
}</code></pre>
<p>In the above loop, the function <code>rpoint()</code> is passed two parameters: <code>crime.ppp$n</code>, which tells the function how many points to randomly generate, and <em>cityOwin</em>, which tells the function to confine the points to the extent defined by the city boundary.</p>
<p>You can plot the last realization of the homogeneous point process to see what a completely random placement of crime could look like.</p>
<pre class="r"><code>plot(rand.p, pch=1, cex = 0.5, main=NULL, cols=rgb(0,0,0,0.5))</code></pre>
<p><img src="pointpatterns_files/figure-html/unnamed-chunk-23-1.png" /><!-- --></p>
<p>Next, let’s plot the histogram of expected values under the null and add a blue vertical line showing where our observed ANN value lies relative to this distribution.</p>
<pre class="r"><code>hist(mnn.r, main=NULL, las=1, breaks=5, col=&quot;bisque&quot;, xlim=range(mnn.p, mnn.r))
abline(v=mnn.p, col=&quot;blue&quot;)</code></pre>
<p><img src="pointpatterns_files/figure-html/unnamed-chunk-24-1.png" /><!-- --></p>
<p>It’s obvious that the observed value is far smaller than the expected values one could expect under the null hypothesis. A smaller observed value indicates that the stores are far more clustered than expected under the null.</p>
<p>A (pseudo) p-value can be extracted from a Monte Carlo simulation. First, we need to find the number of simulated MNN values greater than our observed MNN value.</p>
<pre class="r"><code>N.greater &lt;- sum(mnn.r &gt; mnn.p)</code></pre>
<p>To compute the p-value, find the end of the distribution closest to the observed MNN value, then divide that count by the total count.</p>
<pre class="r"><code>p &lt;- min(N.greater + 1, n + 1 - N.greater) / (n +1)
p</code></pre>
<pre><code>## [1] 0.001666667</code></pre>
<p>In the histogram produced above, you’ll note that the observed MNN value was nowhere near the range of MNN values computed under the null yet we don’t have a p-value of zero. This is by design since the strength of our estimated p-value will be proportional to the number of simulations–this reflects the chance that given an infinite number of simulations at least one realization of a point pattern could produce an MNN value more extreme than ours.</p>
<div style="margin-bottom:25px;">

</div>
</div>
</div>
<div id="distance-functions" class="section level3">
<h3><strong>Distance Functions</strong></h3>
<p><br />
The F, G, K and L functions are discussed on pages 145-148. Our good friend <strong>spatstat</strong> provides canned functions for estimating these distributions.</p>
<p>The K-function which summarizes the distance between points for all distances. The calculation of K consists of dividing the mean of the sum of the number of points at different distance lags for each point by the area event density.</p>
<p>To compute the K function, type:</p>
<pre class="r"><code>K &lt;- Kest(crime.ppp)</code></pre>
<p>Then plot it like on page 146.</p>
<pre class="r"><code>par(mfrow=c(1,1))
plot(K)</code></pre>
<p><img src="pointpatterns_files/figure-html/unnamed-chunk-28-1.png" /><!-- --></p>
<p>The plot returns different estimates of K depending on the edge correction chosen. By default, the isotropic, translate and border corrections are implemented. Edge corrections were discussed on pages 137-139.</p>
<p>Unsurprisingly perhaps, to calculate the G, F and L functions, use the functions <code>Gest()</code>, <code>Fest()</code>, and <code>Lest()</code>, respectively.</p>
<p>OSU discusses calculating envelopes around the functions to examine whether the observed functions are simply due to chance. Use the <code>envelope()</code> function to create the envelopes. Here, we use 49 Monte Carlo simulations.</p>
<pre class="r"><code>envK &lt;- envelope(crime.ppp, fun = Kest, nsim = 49)</code></pre>
<pre><code>## Generating 49 simulations of CSR  ...
## 1, 2,  [etd 6:20] 3,  [etd 6:09] 4,
##  [etd 5:57] 5,  [etd 5:51] 6,  [etd 5:43] 7,  [etd 5:40] 8,
##  [etd 5:33] 9,  [etd 5:23] 10,  [etd 5:16] 11,  [etd 5:08] 12,
##  [etd 5:01] 13,  [etd 4:53] 14,  [etd 4:47] 15,  [etd 4:45] 16,
##  [etd 4:37] 17,  [etd 4:30] 18,  [etd 4:21] 19,  [etd 4:12] 20,
##  [etd 4:03] 21,  [etd 3:55] 22,  [etd 3:49] 23,  [etd 3:44] 24,
##  [etd 3:37] 25,  [etd 3:29] 26,  [etd 3:23] 27,  [etd 3:18] 28,
##  [etd 3:10] 29,  [etd 3:03] 30,  [etd 2:54] 31,  [etd 2:44] 32,
##  [etd 2:36] 33,  [etd 2:27] 34,  [etd 2:18] 35,  [etd 2:08] 36,
##  [etd 1:59] 37,  [etd 1:50] 38,  [etd 1:40] 39,  [etd 1:31] 40,
##  [etd 1:22] 41,  [etd 1:13] 42,  [etd 1:04] 43,  [etd 54 sec] 44,
##  [etd 45 sec] 45,  [etd 36 sec] 46,  [etd 27 sec] 47,  [etd 18 sec] 48,
##  [etd 9 sec]  49.
## 
## Done.</code></pre>
<pre class="r"><code>plot(envK)</code></pre>
<p><img src="pointpatterns_files/figure-html/unnamed-chunk-29-1.png" /><!-- --></p>
<p>It’s hard to see, but R is plotting the envelopes. They are just really narrow. Replace <code>Kest</code> with <code>Gest</code>, <code>Fest</code>, and <code>Lest</code> to get envelopes for the other alphabet functions.</p>
<p><br></p>
<p class="comment" , style="font-style:normal">
<strong>Question</strong>: Have them calculate G, F and L. Interpret. Also maybe have them calculate for separate crime types.
</p>
<p><br></p>
<div style="margin-bottom:25px;">

</div>
</div>
</div>
<div id="resources" class="section level2">
<h2><strong>Resources</strong></h2>
<p><br />
The procedures in this lab heavily relies on the <strong>spatstat</strong> package, which is very well <a href="https://spatstat.org/">documented</a>.</p>
<p>The data used in this lab was taken from <a href="https://rspatial.org/">rspatial</a>. Robert also shows how you can create “home-brew” versions of some of the <strong>spatstat</strong> functions <a href="https://rspatial.org/raster/rosu/Chapter5.html">here</a>.</p>
<hr />
<p>Website created and maintained by <a href="https://nbrazil.faculty.ucdavis.edu/">Noli Brazil</a></p>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>


</body>
</html>
